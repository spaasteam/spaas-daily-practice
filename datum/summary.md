# 每日一练题目快速导航

* [`第一题: 实现 (5).add(3).minus(2) 功能`](#%E7%AC%AC%E4%B8%80%E9%A2%98%3A%20%E5%AE%9E%E7%8E%B0%20(5).add(3).minus(2)%20%E5%8A%9F%E8%83%BD)
* [`第二题: 算法手写题`](#%E7%AC%AC%E4%BA%8C%E9%A2%98%3A%20%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%99%E9%A2%98)
* [`第三题: 算法手写题`](#%E7%AC%AC%E4%B8%89%E9%A2%98%3A%20%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%99%E9%A2%98)
* [`第四题: 实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度`](#%E7%AC%AC%E5%9B%9B%E9%A2%98%3A%20%E5%AE%9E%E7%8E%B0%20convert%20%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8A%8A%E5%8E%9F%E5%A7%8B%20list%20%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%EF%BC%8C%E8%A6%81%E6%B1%82%E5%B0%BD%E5%8F%AF%E8%83%BD%E9%99%8D%E4%BD%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
* [`第五题 要求设计 LazyMan 类，实现以下功能`](#%E7%AC%AC%E4%BA%94%E9%A2%98%20%E8%A6%81%E6%B1%82%E8%AE%BE%E8%AE%A1%20LazyMan%20%E7%B1%BB%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BB%A5%E4%B8%8B%E5%8A%9F%E8%83%BD)
* [`第六题 走迷宫`](#%E7%AC%AC%E5%85%AD%E9%A2%98%20%E8%B5%B0%E8%BF%B7%E5%AE%AB)
* [`第七题 旋转数组`](#%E7%AC%AC%E4%B8%83%E9%A2%98%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%E9%A2%98)
* [`第八题 算法题之 [移动零]`](#%E7%AC%AC%E5%85%AB%E9%A2%98%20%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E3%80%8C%E7%A7%BB%E5%8A%A8%E9%9B%B6%E3%80%8D)
* [`第九题 算法题之翻转数字`](#%E7%AC%AC%E4%B9%9D%E9%A2%98%20%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E7%BF%BB%E8%BD%AC%E6%95%B0%E5%AD%97)
* [`第十题 下面代码中 a 在什么情况下会打印 1 ?`](#%E7%AC%AC%E5%8D%81%E9%A2%98%20%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E4%B8%AD%20a%20%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%89%93%E5%8D%B0%201%20?)
* [`第 11 题 两个数组合并成一个数组`](#%E7%AC%AC%2011%20%E9%A2%98%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84)
* [`第 12 题 查找一个数`](#%E7%AC%AC%2012%20%E9%A2%98%20%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0)
* [`第 13 题 学习数据结构-栈，写一个函数match(str)，判断一个字符串中的小括号是否匹配。`](%E7%AC%AC%2013%20%E9%A2%98%20%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%EF%BC%8C%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0match(str)%EF%BC%8C%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8B%AC%E5%8F%B7%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D%E3%80%82)
* [`第 14 题 [css] 圣杯布局和双飞翼布局的理解和区别，并用代码实现`](#%E7%AC%AC%2014%20%E9%A2%98%20%5Bcss%5D%20%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E7%94%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
* [`第 15 题 请实现一个数组乱序方法`](#%E7%AC%AC%2015%20%E9%A2%98%20%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F%E6%96%B9%E6%B3%95)
* [`第 16 题 设计链表`](#%E7%AC%AC%2016%20%E9%A2%98%20%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8)
 

---


## 题目以及答案汇总

### 第一题: 实现 (5).add(3).minus(2) 功能

解析: [第 1 题](https://github.com/spaasteam/spaas-daily-practice/issues/1)

### 第二题: 算法手写题

> 已知如下数组：
>
> var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
>
> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

解析: [第 2 题](https://github.com/spaasteam/spaas-daily-practice/issues/4)


### 第三题: 算法手写题

> 这是一个大题目，分为4个考点，需要候选人用递归算法实现，限制15行代码内实现。
  - 创建一个长度为 5 的空数组 arr
  - 生成一个 (2 ~ 32) 之间的随机整数 rand
  - 把随机数 rand 插入数组 arr 内，如果数组 arr 内已存在与 rand 相同数字，则重新生成随机数并插入到 arr 内（需要用递归实现，不能使用 for/while 等循环）
  - 最终输出一个长度为5，且内容不重复的数组 arr

做题链接: [第 3 题](https://github.com/spaasteam/spaas-daily-practice/issues/5)




### 第四题: 实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度

以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：

<details>
<summary>详情</summary>

```js
// 原始 list 如下
let list =[
    {id:1,name:'部门A',parentId:0},
    {id:2,name:'部门B',parentId:0},
    {id:3,name:'部门C',parentId:1},
    {id:4,name:'部门D',parentId:1},
    {id:5,name:'部门E',parentId:2},
    {id:6,name:'部门F',parentId:3},
    {id:7,name:'部门G',parentId:2},
    {id:8,name:'部门H',parentId:4}
];
const result = convert(list, ...);

// 转换后的结果如下
let result = [
    {
      id: 1,
      name: '部门A',
      parentId: 0,
      children: [
        {
          id: 3,
          name: '部门C',
          parentId: 1,
          children: [
            {
              id: 6,
              name: '部门F',
              parentId: 3
            }, {
              id: 16,
              name: '部门L',
              parentId: 3
            }
          ]
        },
        {
          id: 4,
          name: '部门D',
          parentId: 1,
          children: [
            {
              id: 8,
              name: '部门H',
              parentId: 4
            }
          ]
        }
      ]
    },
  ···
];
```

</details>

做题链接: [第 4 题](https://github.com/spaasteam/spaas-daily-practice/issues/6)

### 第五题 要求设计 LazyMan 类，实现以下功能

```js
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony').sleep(10).eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

做题链接: [第 5 题](https://github.com/spaasteam/spaas-daily-practice/issues/7)




### 第六题 走迷宫

```js
/**
 * @title 迷宫
 * @description
 * 1. 实现一个函数 getMazePath(迷宫矩阵，开始位置, 结束位置)，
 *     获得从迷宫（二维数组）开始位置到结束位置的所有坐标，按先后顺序排序
 * 2. 1为不可走，0为可走
 * 3. 广度优先算法
 */

// 迷宫
const maze = [
  [1, 1, 1, 1, 1],
  [1, 1, 0, 0, 0],
  [1, 0, 0, 1, 1],
  [0, 0, 1, 0, 1],
  [1, 0, 0, 0, 1],
  [1, 1, 1, 1, 1],
]
const mazePaths = getMazePath(maze, [3, 0], [1, 4])
console.log(mazePaths)
// output: [ [3,0], [3,1], [2,1], [2,2], [1,2], [1,3], [1,4]]
```

做题链接: [第 6 题](https://github.com/spaasteam/spaas-daily-practice/issues/8)


###  第七题 旋转数组算法题

```js
// 编写一个函数 rotate 达到旋转数组的效果

function rotate(A) {}

const arr = [1, 2, 3, 4, 5]

rotate(arr)  // [5, 4, 3, 2, 1]
```

做题连接: [第 7 题](https://github.com/spaasteam/spaas-daily-practice/issues/9)


### 第八题 算法题之「移动零」

>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
>示例:
>
>输入: [0,1,0,3,12]
>输出: [1,3,12,0,0]
>说明:
>
>必须在原数组上操作，不能拷贝额外的数组。
>
>尽量减少操作次数

做题链接: [第八题](https://github.com/spaasteam/spaas-daily-practice/issues/10)


### 第九题 算法题之翻转数字

>用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用>递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。

做题链接: [第 9 题](https://github.com/spaasteam/spaas-daily-practice/issues/11)


### 第十题 下面代码中 a 在什么情况下会打印 1 ?

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}

```

做题链接: [第 10 题](https://github.com/spaasteam/spaas-daily-practice/issues/12)


### 第 11 题两个数组合并成一个数组

请把两个数组 ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 ['A', 'B', 'C', 'D']，合并为 ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']。

做题链接: [第 11 题](https://github.com/spaasteam/spaas-daily-practice/issues/13)


### 第 12 题 查找一个数

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 [来源：力扣（LeetCode）]

提示
- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。
- 可尝试二分查找

做题链接: [第 12 题](https://github.com/spaasteam/spaas-daily-practice/issues/14)


### 第 13 题 学习数据结构-栈，写一个函数match(str)，判断一个字符串中的小括号是否匹配。

```js
match('abc()def') // true
match('(1+2()') // false
match('(1+2+3+5*2*(3+7))') // true
```

做题链接: [第 13 题](https://github.com/spaasteam/spaas-daily-practice/issues/15)


### 第 14 题 [css] 圣杯布局和双飞翼布局的理解和区别，并用代码实现

做题连接: [第 14 题](https://github.com/spaasteam/spaas-daily-practice/issues/16)



### 第 15 题 请实现一个数组乱序方法

做题链接: [第 15 题](https://github.com/spaasteam/spaas-daily-practice/issues/17)



### 第 16 题 设计链表

做题链接: [第 16 题](https://github.com/spaasteam/spaas-daily-practice/issues/18)
